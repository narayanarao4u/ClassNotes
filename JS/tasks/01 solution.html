<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Visual Tasks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .task-container {
            background-color: white;
            border-radius: 0.75rem; /* 12px */
            padding: 1.5rem; /* 24px */
            margin-bottom: 2rem; /* 32px */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .task-title {
            color: #1e3a8a; /* Dark blue */
        }
        .btn {
            background-color: #2563eb; /* Blue */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* 6px */
            font-weight: 500;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #1d4ed8; /* Darker blue */
        }
        .input-field {
            border: 1px solid #cbd5e1; /* Cool gray */
            padding: 0.5rem;
            border-radius: 0.375rem;
            width: 100%;
        }
        .output-area {
            background-color: #e2e8f0; /* Lighter cool gray */
            padding: 1rem;
            border-radius: 0.375rem;
            margin-top: 1rem;
            min-height: 50px;
            white-space: pre-wrap; /* To respect newlines in patterns */
            font-family: monospace;
        }
        .traffic-light div {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 10px auto;
            background-color: #7f8c8d; /* Gray, inactive */
            border: 2px solid #34495e; /* Darker gray border */
        }
        .traffic-light .red-active { background-color: #e74c3c; /* Red */ }
        .traffic-light .yellow-active { background-color: #f1c40f; /* Yellow */ }
        .traffic-light .green-active { background-color: #2ecc71; /* Green */ }

        #treeCanvas {
            border: 1px solid #cbd5e1;
            background-color: #f8fafc; /* Very light gray for canvas */
            border-radius: 0.375rem;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-blue-700">JavaScript Visual Tasks</h1>
            <p class="text-lg text-gray-600 mt-2">Intermediate Level Challenges</p>
        </header>

        <section id="task1" class="task-container">
            <h2 class="text-2xl font-semibold mb-4 task-title">Task 1: Text Analyzer (String Methods)</h2>
            <p class="text-gray-700 mb-3">Enter some text below and see various analyses performed using string methods.</p>
            <textarea id="stringInput" class="input-field mb-3 h-24" placeholder="Type or paste text here..."></textarea>
            <button id="analyzeStringBtn" class="btn mb-3 w-full sm:w-auto">Analyze Text</button>
            <div id="stringOutput" class="output-area">Analysis results will appear here.</div>
        </section>

        <section id="task2" class="task-container">
            <h2 class="text-2xl font-semibold mb-4 task-title">Task 2: Traffic Light Simulator (Conditions)</h2>
            <p class="text-gray-700 mb-3">Click the button to cycle through traffic light states. The light also changes automatically.</p>
            <div class="traffic-light text-center mb-3">
                <div id="redLight"></div>
                <div id="yellowLight"></div>
                <div id="greenLight"></div>
            </div>
            <button id="changeLightBtn" class="btn w-full sm:w-auto">Change Light Manually</button>
            <p id="lightStatus" class="text-center mt-2 font-medium text-gray-700"></p>
        </section>

        <section id="task3" class="task-container">
            <h2 class="text-2xl font-semibold mb-4 task-title">Task 3: Pattern Generator (Loops)</h2>
            <p class="text-gray-700 mb-3">Enter a number to generate a pyramid pattern using loops.</p>
            <input type="number" id="loopInput" class="input-field mb-3" placeholder="Enter a number (e.g., 5)" min="1" max="15">
            <button id="generatePatternBtn" class="btn mb-3 w-full sm:w-auto">Generate Pattern</button>
            <div id="loopOutput" class="output-area">Pattern will appear here.</div>
        </section>

        <section id="task4" class="task-container">
            <h2 class="text-2xl font-semibold mb-4 task-title">Task 4: Recursive Fractal Tree (Functions & Recursion)</h2>
            <p class="text-gray-700 mb-3">Click the button to draw a simple fractal tree using a recursive function. The drawing happens on the canvas below.</p>
            <button id="drawTreeBtn" class="btn mb-3 w-full sm:w-auto">Draw Tree</button>
            <canvas id="treeCanvas" width="500" height="350" class="mx-auto block"></canvas>
            <p class="text-sm text-gray-600 mt-2 text-center">A callback function logs to the console when each major branch segment is drawn.</p>
        </section>

        <section id="task5" class="task-container">
            <h2 class="text-2xl font-semibold mb-4 task-title">Task 5: Timed Events (setTimeout & setInterval)</h2>
            
            <div class="mb-6">
                <h3 class="text-xl font-medium text-gray-800 mb-2">Delayed Message (setTimeout)</h3>
                <p class="text-gray-700 mb-3">Click the button, and a message will appear below after 3 seconds.</p>
                <button id="showMessageBtn" class="btn w-full sm:w-auto">Show Delayed Message</button>
                <div id="delayedMessageOutput" class="output-area mt-2 h-12"></div>
            </div>

            <div class="mb-6">
                <h3 class="text-xl font-medium text-gray-800 mb-2">Blinking Text (setInterval)</h3>
                <p class="text-gray-700 mb-3">The text below will start blinking once the page loads.</p>
                <div id="blinkingText" class="text-2xl font-bold text-center p-4 rounded-md bg-yellow-100 text-yellow-700">Blink! Blink!</div>
            </div>
            
            <div>
                <h3 class="text-xl font-medium text-gray-800 mb-2">Countdown Timer (setInterval & setTimeout)</h3>
                <p class="text-gray-700 mb-3">Enter seconds for a countdown. The timer will update every second and show a message when done.</p>
                <input type="number" id="countdownInput" class="input-field mb-2 w-full sm:w-1/2" placeholder="Seconds (e.g., 10)" min="1">
                <button id="startCountdownBtn" class="btn mb-3 w-full sm:w-auto">Start Countdown</button>
                <div id="countdownOutput" class="output-area text-3xl font-mono text-center h-20 flex items-center justify-center">00:00</div>
            </div>
        </section>

    </div>

    <script>
        // --- Task 1: String Methods ---
        const stringInput = document.getElementById('stringInput');
        const analyzeStringBtn = document.getElementById('analyzeStringBtn');
        const stringOutput = document.getElementById('stringOutput');

        analyzeStringBtn.addEventListener('click', () => {
            const text = stringInput.value;
            if (!text.trim()) {
                stringOutput.textContent = 'Please enter some text.';
                return;
            }

            const wordCount = text.split(/\s+/).filter(word => word.length > 0).length;
            const charCount = text.length;
            const charCountNoSpace = text.replace(/\s/g, '').length;
            
            // Vowel count (case-insensitive)
            const vowels = text.match(/[aeiou]/gi);
            const vowelCount = vowels ? vowels.length : 0;

            const reversedText = text.split('').reverse().join('');
            const firstTenChars = text.substring(0, 10);
            const lastTenChars = text.substring(text.length - 10);
            const upperCaseText = text.toUpperCase();
            const lowerCaseText = text.toLowerCase();

            stringOutput.innerHTML = `
                <strong>Original Text Length:</strong> ${charCount} characters<br>
                <strong>Length (no spaces):</strong> ${charCountNoSpace} characters<br>
                <strong>Word Count:</strong> ${wordCount}<br>
                <strong>Vowel Count:</strong> ${vowelCount}<br>
                <strong>First 10 Chars:</strong> "${firstTenChars}..."<br>
                <strong>Last 10 Chars:</strong> "...${lastTenChars}"<br>
                <strong>Reversed Text:</strong> ${reversedText.substring(0,50)}... <br>
                <strong>Uppercase:</strong> ${upperCaseText.substring(0,50)}... <br>
                <strong>Lowercase:</strong> ${lowerCaseText.substring(0,50)}...
            `;
        });

        // --- Task 2: Conditions ---
        const redLight = document.getElementById('redLight');
        const yellowLight = document.getElementById('yellowLight');
        const greenLight = document.getElementById('greenLight');
        const changeLightBtn = document.getElementById('changeLightBtn');
        const lightStatus = document.getElementById('lightStatus');

        let currentLightState = 'red'; // Initial state
        let autoChangeInterval;

        function setLightState(state) {
            // Reset all lights
            redLight.classList.remove('red-active');
            yellowLight.classList.remove('yellow-active');
            greenLight.classList.remove('green-active');

            currentLightState = state; // Update current state

            // Activate the correct light
            if (state === 'red') {
                redLight.classList.add('red-active');
                lightStatus.textContent = 'STOP';
                lightStatus.className = 'text-center mt-2 font-medium text-red-600';
            } else if (state === 'yellow') {
                yellowLight.classList.add('yellow-active');
                lightStatus.textContent = 'CAUTION';
                lightStatus.className = 'text-center mt-2 font-medium text-yellow-500';
            } else if (state === 'green') {
                greenLight.classList.add('green-active');
                lightStatus.textContent = 'GO';
                lightStatus.className = 'text-center mt-2 font-medium text-green-600';
            }
        }

        function cycleLight() {
            if (currentLightState === 'red') {
                setLightState('green');
            } else if (currentLightState === 'green') {
                setLightState('yellow');
            } else if (currentLightState === 'yellow') {
                setLightState('red');
            }
        }
        
        changeLightBtn.addEventListener('click', () => {
            cycleLight();
            // Reset and restart automatic timer if manually changed
            clearInterval(autoChangeInterval);
            startAutomaticLightChange();
        });

        function startAutomaticLightChange() {
            autoChangeInterval = setInterval(() => {
                if (currentLightState === 'red') {
                    setLightState('green');
                } else if (currentLightState === 'green') {
                    // Green light stays longer
                    setTimeout(() => {
                         if(currentLightState === 'green') setLightState('yellow'); // Check state again in case of manual override
                    }, 2000); // Green duration part 1
                } else if (currentLightState === 'yellow') {
                    setLightState('red');
                }
            }, 4000); // Base interval for red/yellow
        }

        // Initialize traffic light
        setLightState('red');
        startAutomaticLightChange();


        // --- Task 3: Loops ---
        const loopInput = document.getElementById('loopInput');
        const generatePatternBtn = document.getElementById('generatePatternBtn');
        const loopOutput = document.getElementById('loopOutput');

        generatePatternBtn.addEventListener('click', () => {
            const num = parseInt(loopInput.value);
            if (isNaN(num) || num < 1 || num > 15) {
                loopOutput.textContent = 'Please enter a number between 1 and 15.';
                return;
            }

            let pattern = '';
            // Outer loop for rows
            for (let i = 1; i <= num; i++) {
                // Inner loop for spaces (to center the pyramid)
                for (let j = 1; j <= num - i; j++) {
                    pattern += '  '; // Two spaces for better visual
                }
                // Inner loop for stars/characters
                for (let k = 1; k <= (2 * i - 1); k++) {
                    pattern += '* ';
                }
                pattern += '\n'; // Newline after each row
            }
            loopOutput.textContent = pattern;
        });

        // --- Task 4: Functions, Callback, Recursive Functions ---
        const drawTreeBtn = document.getElementById('drawTreeBtn');
        const treeCanvas = document.getElementById('treeCanvas');
        const ctx = treeCanvas.getContext('2d');

        // Callback function to be called when a branch segment is drawn
        function branchDrawnCallback(startX, startY, endX, endY, level) {
            console.log(`Branch segment drawn from (${startX.toFixed(2)}, ${startY.toFixed(2)}) to (${endX.toFixed(2)}, ${endY.toFixed(2)}) at level ${level}`);
            // You could add more visual feedback here if desired, e.g., temporarily highlighting the branch
        }

        // Recursive function to draw a branch
        function drawBranch(startX, startY, length, angle, lineWidth, level, callback) {
            if (level > 8 || length < 5) { // Base case for recursion: stop if too many levels or branch too short
                return;
            }

            ctx.beginPath();
            ctx.moveTo(startX, startY);

            // Calculate end point of the branch
            const endX = startX + length * Math.cos(angle);
            const endY = startY + length * Math.sin(angle);
            
            ctx.lineTo(endX, endY);
            ctx.lineWidth = lineWidth;
            // Color branches based on level - deeper branches get lighter/greener
            const greenShade = Math.min(200, 50 + level * 20);
            ctx.strokeStyle = `rgb(0, ${greenShade}, 0)`;
            ctx.stroke();

            // Call the callback function
            if (callback) {
                callback(startX, startY, endX, endY, level);
            }

            // Recursive calls for next branches
            // Branch 1: slightly to the left
            drawBranch(endX, endY, length * 0.75, angle - 0.4, Math.max(1, lineWidth * 0.7), level + 1, callback);
            // Branch 2: slightly to the right
            drawBranch(endX, endY, length * 0.75, angle + 0.4, Math.max(1, lineWidth * 0.7), level + 1, callback);
            // Optional: A middle branch for fuller trees
            if (level < 4) { // Only for earlier levels to avoid too much clutter
                 drawBranch(endX, endY, length * 0.6, angle, Math.max(1, lineWidth * 0.6), level + 1, callback);
            }
        }

        drawTreeBtn.addEventListener('click', () => {
            // Clear canvas before drawing
            ctx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
            
            // Starting parameters for the tree trunk
            const startX = treeCanvas.width / 2;
            const startY = treeCanvas.height - 10; // Start near the bottom
            const initialLength = treeCanvas.height / 4.5;
            const initialAngle = -Math.PI / 2; // Pointing upwards
            const initialLineWidth = 10;

            // Main function call to start drawing the tree
            drawBranch(startX, startY, initialLength, initialAngle, initialLineWidth, 1, branchDrawnCallback);
        });


        // --- Task 5: setTimeout, setInterval ---
        // Delayed Message (setTimeout)
        const showMessageBtn = document.getElementById('showMessageBtn');
        const delayedMessageOutput = document.getElementById('delayedMessageOutput');
        let messageTimeoutId = null;

        showMessageBtn.addEventListener('click', () => {
            delayedMessageOutput.textContent = 'Waiting for message...';
            // Clear any existing timeout to prevent multiple messages if clicked rapidly
            if (messageTimeoutId) {
                clearTimeout(messageTimeoutId);
            }
            messageTimeoutId = setTimeout(() => {
                delayedMessageOutput.textContent = 'Hello! This message appeared after 3 seconds!';
                delayedMessageOutput.classList.add('text-green-600', 'font-semibold');
            }, 3000); // 3000 milliseconds = 3 seconds
        });

        // Blinking Text (setInterval)
        const blinkingText = document.getElementById('blinkingText');
        let isVisible = true;
        const blinkIntervalId = setInterval(() => {
            if (isVisible) {
                blinkingText.style.opacity = '0.3';
            } else {
                blinkingText.style.opacity = '1';
            }
            isVisible = !isVisible;
        }, 700); // Blink every 700 milliseconds

        // Countdown Timer (setInterval & setTimeout for completion)
        const countdownInput = document.getElementById('countdownInput');
        const startCountdownBtn = document.getElementById('startCountdownBtn');
        const countdownOutput = document.getElementById('countdownOutput');
        let countdownIntervalId = null;
        let countdownEndTimeoutId = null;

        startCountdownBtn.addEventListener('click', () => {
            const seconds = parseInt(countdownInput.value);
            if (isNaN(seconds) || seconds < 1) {
                countdownOutput.textContent = 'Invalid time!';
                countdownOutput.classList.remove('text-green-500', 'text-red-500');
                return;
            }

            // Clear any existing intervals/timeouts
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            if (countdownEndTimeoutId) clearTimeout(countdownEndTimeoutId);
            
            countdownOutput.classList.remove('text-green-500', 'text-red-500');
            countdownOutput.classList.add('text-blue-600');


            let remainingTime = seconds;
            
            function updateTimerDisplay() {
                const minutes = Math.floor(remainingTime / 60);
                const secs = remainingTime % 60;
                countdownOutput.textContent = `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }

            updateTimerDisplay(); // Initial display

            countdownIntervalId = setInterval(() => {
                remainingTime--;
                updateTimerDisplay();

                if (remainingTime <= 0) {
                    clearInterval(countdownIntervalId);
                    // The setTimeout for "Done!" is handled below, this interval just stops.
                }
            }, 1000);

            // Use setTimeout for the final "Done!" message to ensure it happens after the last interval tick
            countdownEndTimeoutId = setTimeout(() => {
                countdownOutput.textContent = 'Done!';
                countdownOutput.classList.remove('text-blue-600');
                countdownOutput.classList.add('text-green-500', 'font-bold');
            }, seconds * 1000);
        });

        // Cleanup intervals when the window is about to be unloaded (good practice)
        window.addEventListener('beforeunload', () => {
            if (autoChangeInterval) clearInterval(autoChangeInterval);
            if (blinkIntervalId) clearInterval(blinkIntervalId);
            if (countdownIntervalId) clearInterval(countdownIntervalId);
            if (messageTimeoutId) clearTimeout(messageTimeoutId);
            if (countdownEndTimeoutId) clearTimeout(countdownEndTimeoutId);
        });

    </script>
</body>
</html>
